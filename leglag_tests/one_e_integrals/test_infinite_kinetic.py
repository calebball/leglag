"""
Tests that the potential energy integrals are correctly evaluated for infinite
domains.
"""
import numpy as np
import pytest
from hypothesis import given, strategies as st

from leglag.one_d_domain import InfDomain
from leglag.one_e_integrals import inf_kinetic


@pytest.mark.parametrize("side", [True, False])
@given(
    functions=st.integers(min_value=1, max_value=50),
)
def test_kinetic_matrix_shape(side, functions):
    """Tests that the shape of the kinetic energy integral matrix is correct."""
    domain = InfDomain(0, 0, side, 2, 1, functions, None)
    matrix = inf_kinetic(domain)
    assert matrix.shape == (functions, functions)


unscaled_kinetic_matrix = np.array(
    [
        [1,                 2 / np.sqrt(3),     np.sqrt(2 / 3),         np.sqrt(2 / 5),     2 / np.sqrt(15)],
        [2 / np.sqrt(3),    7 / 3,              5 * np.sqrt(2) / 3,     np.sqrt(10 / 3),    2 * np.sqrt(5) / 3],
        [np.sqrt(2 / 3),    5 * np.sqrt(2) / 3, 11 / 3,                 14 / np.sqrt(15),   14 * np.sqrt(10) / 15],
        [np.sqrt(2 / 5),    np.sqrt(10 / 3),    14 / np.sqrt(15),       5,                  2 * np.sqrt(6)],
        [2 / np.sqrt(15),   2 * np.sqrt(5) / 3, 14 * np.sqrt(10) / 15,  2 * np.sqrt(6),     19 / 3],
    ]
)


@pytest.mark.parametrize("side", [True, False])
@given(
    # This max value is the maximum range of the expected data type divided by
    # the largest element of the unscaled kinetic matrix, which prevents an
    # overflow error
    alpha=st.floats(min_value=0, max_value=2 * np.sqrt(np.finfo(np.float64).max) / 6),
)
def test_kinetic_matrix_values(side, alpha):
    """Tests that the kinetic matrix is correctly generated by comparing to an
    analytically constructed example.
    """
    domain = InfDomain(0, 0, side, alpha, 1, 5, None)
    matrix = inf_kinetic(domain)
    assert np.isclose(
        matrix, alpha ** 2 * unscaled_kinetic_matrix / 2, atol=0, rtol=1e-14
    ).all()
